/**
 * Copyright (C) 2015 Orange
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.francetelecom.clara.cloud.logicalmodel;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Inheritance;
import javax.persistence.InheritanceType;
import javax.persistence.Table;
import javax.validation.constraints.NotNull;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;

import org.apache.commons.lang3.Validate;
import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;

import com.francetelecom.clara.cloud.commons.EqualsUtils;
import com.francetelecom.clara.cloud.commons.GuiMapping;
import com.francetelecom.clara.cloud.commons.UUIDUtils;

/**
 * Base class for deployment logical view.
 * 
 * @author APOG7416
 * 
 */

@XmlRootElement
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
@Table(name = "LOGICAL_MODEL_ITEM")
public abstract class LogicalModelItem extends LogicalEntity implements Comparable<LogicalModelItem> {

	@XmlAttribute
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
    @GuiMapping(status = GuiMapping.StatusType.NA)
	protected int id;

    /**
     * Designed as a being the result of the monitoring metrics for a given logical model item.
     *
     * TODO: move this into the TDI instead (with traceability to logical model allowing to display an aggregated view to users)
     */
	@XmlAttribute
    @GuiMapping(status = GuiMapping.StatusType.SKIPPED)
	boolean available = false;

	@XmlAttribute
	@NotNull
    @GuiMapping(status = GuiMapping.StatusType.SKIPPED)
	LogicalModelItemStatusEnum status = LogicalModelItemStatusEnum.TRANSIENT;

	/**
	 * Id is auto generated by JPA, exclude it from semantic comparison.
	 */
	protected static final String[] EXCLUDED_EQUALS_FIELDS = EqualsUtils.mergeExcludedFieldLists(LogicalEntity.EXCLUDED_EQUALS_FIELDS, 
			new String[] {"id"});


    /** The label of the logical item as provided by the end-user.
     * Usually unique among a logical deployment
     */
    //@NotNull  //TODO: uncomment this once we finished migrating all names into labels
    @GuiMapping(status = GuiMapping.StatusType.SUPPORTED)
    protected String label;


    /**
	 * Constructeur vide
	 */
	protected LogicalModelItem() {
        this(UUIDUtils.generateUUID("mi"));
	}

	/**
	 * Constructor
     * @param name a internal name used to identify this LogicalModelItem independently of its database Id.
     * @param label a non null, non empty user-provided label
	 */
	public LogicalModelItem(String name, String label) {
		this(name);
        Validate.notEmpty(label, "expected label to be non empty");
        this.label = label;
    }
	/**
	 * Constructor
	 */
	public LogicalModelItem(String name) {
		this.name = name;
    }

	/**
	 * getter on id. Be careful : no setter on id, only JPA is able to set ids
	 * 
	 * @return the id
	 */
	public int getId() {
		return id;
	}

	/**
	 * setter on id. Be careful : only JPA is able to set ids. It has been put here only for mocks.
	 */
    // FIXME : it has to be deleted when id/name will be refactoring
	public void setId(int id) {
		this.id = id;
	}

	public boolean isAvailable() {
		return available;
	}

	public void setAvailable(boolean available) {
		this.available = available;
	}

	@Override
	 public boolean equals(Object obj) {
		//See http://commons.apache.org/lang/api-2.5/org/apache/commons/lang/builder/HashCodeBuilder.html
		return EqualsBuilder.reflectionEquals(this, obj, EXCLUDED_EQUALS_FIELDS);
	}

	@Override
	public int hashCode() {
		return HashCodeBuilder.reflectionHashCode(this, EXCLUDED_EQUALS_FIELDS);
	}

	/**
	 * Utility method for subclasses to request equals with fields at our level, but excluding subclasses
	 * fields
	 */
	protected boolean equals(Object obj, String[] excludedSubclassfields) {
		return EqualsBuilder.reflectionEquals(this, obj, EqualsUtils.mergeExcludedFieldLists(excludedSubclassfields, EXCLUDED_EQUALS_FIELDS));
	}

	/**
	 * Utility method for subclasses to request hashCode with fields at our level, but excluding subclasses
	 * fields
	 */
	protected int hashCode(String[] excludedSubclassfields) {
		return HashCodeBuilder.reflectionHashCode(this, EqualsUtils.mergeExcludedFieldLists(excludedSubclassfields, EXCLUDED_EQUALS_FIELDS));
	}

    @Override
    protected boolean isFieldExcludedFromToString(String fieldName) {
        return isFieldExcludedFromToString(fieldName, LogicalModelItem.EXCLUDED_EQUALS_FIELDS);
    }

    public String getLabel() {
        return label;
    }

    public void setLabel(String label) {
        this.label = label;
    }

    /**
     * {@link LogicalModelItem#equals(Object)} depends on this
     * @param o
     * @return
     */
    @Override
    public int compareTo(LogicalModelItem o) {
        //Sorting based on class names, and labels among class names which are supposed to be unique.
        //Note: we expect labels to be set, however if one is null, this should be OK, order will always be consistent
        //and labels are tested in equals.
        String name1 = this.getClass().getSimpleName() + getLabel();
        String name2 = o.getClass().getSimpleName() + o.getLabel();
        return name1.compareTo(name2);
    }
}
